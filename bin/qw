#!/usr/bin/env ruby
# Add qwandry's library to the load path
$:.unshift File.dirname(__FILE__) + '/../lib'
# Require it
require "qwandry.rb"

recipe_paths = Dir[
  (ENV['HOME']||'')+'/.qwandry/*.rb',                     # custom recipes
  File.dirname(__FILE__)+'/../lib/qwandry/recipes/*.rb',  # built in recipes
]

opts = OptionParser.new do |opts|    
  opts.banner = "Usage: qwandry [options] name"
  opts.separator ""
  
  recipe_names = recipe_paths.map{|path| File.basename(path,'.rb')}.uniq
  opts.on("-r", "--recipe RECIPE", "Use paths from RECIPE","Recipes:", *recipe_names.map{|k| "* #{k}"}) do |recipe|
    if recipe_names.include?(recipe)
      @recipe = recipe 
    else
      STDERR.puts "Recipe '#{recipe}' is not available, using default."
    end
  end
  
  opts.on("-e", "--editor EDITOR", "Use EDITOR to open the package") do |editor|
    @editor = editor
  end
  
  opts.on_tail("-h", "--help", "Show this message") do
    puts opts
    exit
  end
end

opts.parse! ARGV
if ARGV.length != 1
  puts opts
  exit(1)
end

# Create launcher
@qwandry = Qwandry::Launcher.new

# Configure default values
@qwandry.editor = @editor if @editor

# Load recipe
@recipe ||= 'default'
@recipe_path = recipe_paths.find{|p| File.basename(p,'.rb') == @recipe }
unless @recipe_path
  STDERR.puts "Could not find recipe '#{@recipe}'"
  exit(1)
end
# Configure @qwandry
@qwandry.instance_eval(File.read(@recipe_path) )

name = ARGV.pop
packages = @qwandry.find(name)

package = nil
case packages.length
when 0
  puts "No packages matched '#{name}'"
  exit 404 # Package not found -- hehe, super lame.
when 1
  package = packages.first
else
  packages.each_with_index do |package, index|
    puts "%3d. %s" % [index+1, package.name]
  end

  print ">> "
  index = gets.to_i-1
  package = packages[index]
end

@qwandry.launch(package) if package